{"ast":null,"code":"var PI = Math.PI;\n/**\r\n * Modulate a value between two ranges.\r\n * @param value\r\n * @param rangeA from [low, high]\r\n * @param rangeB to [low, high]\r\n * @param clamp\r\n */\n\nfunction modulate(value, rangeA, rangeB, clamp) {\n  if (clamp === void 0) {\n    clamp = false;\n  }\n\n  var fromLow = rangeA[0],\n      fromHigh = rangeA[1];\n  var toLow = rangeB[0],\n      toHigh = rangeB[1];\n  var result = toLow + (value - fromLow) / (fromHigh - fromLow) * (toHigh - toLow);\n\n  if (clamp === true) {\n    if (toLow < toHigh) {\n      if (result < toLow) {\n        return toLow;\n      }\n\n      if (result > toHigh) {\n        return toHigh;\n      }\n    } else {\n      if (result > toLow) {\n        return toLow;\n      }\n\n      if (result < toHigh) {\n        return toHigh;\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Rotate a point around a center.\r\n * @param x The x-axis coordinate of the point.\r\n * @param y The y-axis coordinate of the point.\r\n * @param cx The x-axis coordinate of the point to rotate round.\r\n * @param cy The y-axis coordinate of the point to rotate round.\r\n * @param angle The distance (in radians) to rotate.\r\n */\n\n\nfunction rotatePoint(x, y, cx, cy, angle) {\n  var s = Math.sin(angle);\n  var c = Math.cos(angle);\n  var px = x - cx;\n  var py = y - cy;\n  var nx = px * c - py * s;\n  var ny = px * s + py * c;\n  return [nx + cx, ny + cy];\n}\n/**\r\n * Get the distance between two points.\r\n * @param x0 The x-axis coordinate of the first point.\r\n * @param y0 The y-axis coordinate of the first point.\r\n * @param x1 The x-axis coordinate of the second point.\r\n * @param y1 The y-axis coordinate of the second point.\r\n */\n\n\nfunction getDistance(x0, y0, x1, y1) {\n  return Math.hypot(y1 - y0, x1 - x0);\n}\n/**\r\n * Get an angle (radians) between two points.\r\n * @param x0 The x-axis coordinate of the first point.\r\n * @param y0 The y-axis coordinate of the first point.\r\n * @param x1 The x-axis coordinate of the second point.\r\n * @param y1 The y-axis coordinate of the second point.\r\n */\n\n\nfunction getAngle(x0, y0, x1, y1) {\n  return Math.atan2(y1 - y0, x1 - x0);\n}\n/**\r\n * Move a point in an angle by a distance.\r\n * @param x0\r\n * @param y0\r\n * @param a angle (radians)\r\n * @param d distance\r\n */\n\n\nfunction projectPoint(x0, y0, a, d) {\n  return [Math.cos(a) * d + x0, Math.sin(a) * d + y0];\n}\n/**\r\n * Get a point between two points.\r\n * @param x0 The x-axis coordinate of the first point.\r\n * @param y0 The y-axis coordinate of the first point.\r\n * @param x1 The x-axis coordinate of the second point.\r\n * @param y1 The y-axis coordinate of the second point.\r\n * @param d Normalized\r\n */\n\n\nfunction getPointBetween(x0, y0, x1, y1, d) {\n  if (d === void 0) {\n    d = 0.5;\n  }\n\n  return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d];\n}\n/**\r\n * Get the sector of an angle (e.g. quadrant, octant)\r\n * @param a The angle to check.\r\n * @param s The number of sectors to check.\r\n */\n\n\nfunction getSector(a, s) {\n  if (s === void 0) {\n    s = 8;\n  }\n\n  return Math.floor(s * (0.5 + a / (PI * 2) % s));\n}\n/**\r\n * Get a normal value representing how close two points are from being at a 45 degree angle.\r\n * @param x0 The x-axis coordinate of the first point.\r\n * @param y0 The y-axis coordinate of the first point.\r\n * @param x1 The x-axis coordinate of the second point.\r\n * @param y1 The y-axis coordinate of the second point.\r\n */\n\n\nfunction getAngliness(x0, y0, x1, y1) {\n  return Math.abs((x1 - x0) / 2 / ((y1 - y0) / 2));\n}\n/**\r\n * Check whether two rectangles will collide (overlap).\r\n * @param x0 The x-axis coordinate of the first rectangle.\r\n * @param y0 The y-axis coordinate of the first rectangle.\r\n * @param w0 The width of the first rectangle.\r\n * @param h0 The height of the first rectangle.\r\n * @param x1 The x-axis coordinate of the second rectangle.\r\n * @param y1 The y-axis coordinate of the second rectangle.\r\n * @param w1 The width of the second rectangle.\r\n * @param h1 The height of the second rectangle.\r\n */\n\n\nfunction doRectanglesCollide(x0, y0, w0, h0, x1, y1, w1, h1) {\n  return !(x0 >= x1 + w1 || x1 >= x0 + w0 || y0 >= y1 + h1 || y1 >= y0 + h0);\n}\n/**\r\n * Get the point(s) where a line segment intersects a circle.\r\n * @param cx The x-axis coordinate of the circle's center.\r\n * @param cy The y-axis coordinate of the circle's center.\r\n * @param r The circle's radius.\r\n * @param x0 The x-axis coordinate of the segment's starting point.\r\n * @param y0 The y-axis coordinate of ththe segment's ending point.\r\n * @param x1 The delta-x of the ray.\r\n * @param y1 The delta-y of the ray.\r\n */\n\n\nfunction getSegmentCircleIntersections(cx, cy, r, x0, y0, x1, y1) {\n  var b,\n      c,\n      d,\n      u1,\n      u2,\n      ret,\n      retP1,\n      retP2,\n      v1 = [x1 - x0, y1 - y0],\n      v2 = [x0 - cx, y0 - cy];\n  b = v1[0] * v2[0] + v1[1] * v2[1];\n  c = 2 * (v1[0] * v1[0] + v1[1] * v1[1]);\n  b *= -2;\n  d = Math.sqrt(b * b - 2 * c * (v2[0] * v2[0] + v2[1] * v2[1] - r * r));\n\n  if (isNaN(d)) {\n    // no intercept\n    return [];\n  }\n\n  u1 = (b - d) / c; // these represent the unit distance of point one and two on the line\n\n  u2 = (b + d) / c;\n  retP1 = []; // return points\n\n  retP2 = [];\n  ret = []; // return array\n\n  if (u1 <= 1 && u1 >= 0) {\n    // add point if on the line segment\n    retP1[0] = x0 + v1[0] * u1;\n    retP1[1] = y0 + v1[1] * u1;\n    ret[0] = retP1;\n  }\n\n  if (u2 <= 1 && u2 >= 0) {\n    // second add point if on the line segment\n    retP2[0] = x0 + v1[0] * u2;\n    retP2[1] = y0 + v1[1] * u2;\n    ret[ret.length] = retP2;\n  }\n\n  return ret;\n}\n/**\r\n * Normalize an angle (in radians)\r\n * @param radians The radians quantity to normalize.\r\n */\n\n\nfunction normalizeAngle(radians) {\n  return radians - PI * 2 * Math.floor(radians / (PI * 2));\n}\n/**\r\n * Get the point at which a ray intersects a segment.\r\n * @param x The x-axis coordinate of the ray's origin.\r\n * @param y The y-axis coordinate of the ray's origin.\r\n * @param dx The x-axis delta of the angle.\r\n * @param dy The y-axis delta of the angle.\r\n * @param x0 The x-axis coordinate of the segment's start point.\r\n * @param y0 The y-axis coordinate of the segment's start point.\r\n * @param x1 The x-axis coordinate of the segment's end point.\r\n * @param y1 The y-axis coordinate of the segment's end point.\r\n */\n\n\nfunction getRaySegmentIntersection(x, y, dx, dy, x0, y0, x1, y1) {\n  var r, s, d;\n\n  if (dy * (x1 - x0) !== dx * (y1 - y0)) {\n    d = dx * (y1 - y0) - dy * (x1 - x0);\n\n    if (d !== 0) {\n      r = ((y - y0) * (x1 - x0) - (x - x0) * (y1 - y0)) / d;\n      s = ((y - y0) * dx - (x - x0) * dy) / d;\n\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return [x + r * dx, y + r * dy];\n      }\n    }\n  }\n\n  return undefined;\n}\n/**\r\n * Get the normalized delta (x and y) for an angle.\r\n * @param angle The angle in radians\r\n */\n\n\nfunction getDelta(angle) {\n  return [Math.cos(angle), Math.sin(angle)];\n}\n\nfunction getIntermediate(angle) {\n  return Math.abs(Math.abs(angle % (PI / 2)) - PI / 4) / (PI / 4);\n}\n/**\r\n * Get a line between two rounded rectangles.\r\n * @param x0\r\n * @param y0\r\n * @param w0\r\n * @param h0\r\n * @param r0\r\n * @param x1\r\n * @param y1\r\n * @param w1\r\n * @param h1\r\n * @param r1\r\n */\n\n\nfunction getLineBetweenRoundedRectangles(x0, y0, w0, h0, r0, x1, y1, w1, h1, r1) {\n  var cx0 = x0 + w0 / 2,\n      cy0 = y0 + h0 / 2,\n      cx1 = x1 + w1 / 2,\n      cy1 = y1 + h1 / 2,\n      _ref3 = getRayRoundedRectangleIntersection(cx0, cy0, cx1 - cx0, cy1 - cy0, x0, y0, w0, h0, r0) || [[cx0, cy0]],\n      _ref3$ = _ref3[0],\n      di0x = _ref3$[0],\n      di0y = _ref3$[1],\n      _ref4 = getRayRoundedRectangleIntersection(cx1, cy1, cx0 - cx1, cy0 - cy1, x1, y1, w1, h1, r1) || [[cx1, cy1]],\n      _ref4$ = _ref4[0],\n      di1x = _ref4$[0],\n      di1y = _ref4$[1];\n\n  return [di0x, di0y, di1x, di1y];\n}\n/**\r\n * Get the intersection points between a ray and a rectangle with rounded corners.\r\n * @param ox The x-axis coordinate of the ray's origin.\r\n * @param oy The y-axis coordinate of the ray's origin.\r\n * @param dx The delta-x of the ray.\r\n * @param dy The delta-y of the ray.\r\n * @param x The x-axis coordinate of the rectangle.\r\n * @param y The y-axis coordinate of the rectangle.\r\n * @param w The width of the rectangle.\r\n * @param h The height of the rectangle.\r\n * @param r The corner radius of the rectangle.\r\n */\n\n\nfunction getRayRoundedRectangleIntersection(ox, oy, dx, dy, x, y, w, h, r) {\n  var mx = x + w,\n      my = y + h,\n      rx = x + r - 1,\n      ry = y + r - 1,\n      mrx = x + w - r + 1,\n      mry = y + h - r + 1;\n  var segments = [[x, mry, x, ry], [rx, y, mrx, y], [mx, ry, mx, mry], [mrx, my, rx, my]];\n  var corners = [[rx, ry, Math.PI, Math.PI * 1.5], [mrx, ry, Math.PI * 1.5, Math.PI * 2], [mrx, mry, 0, Math.PI * 0.5], [rx, mry, Math.PI * 0.5, Math.PI]];\n  var points = [];\n  segments.forEach(function (segment, i) {\n    var px0 = segment[0],\n        py0 = segment[1],\n        px1 = segment[2],\n        py1 = segment[3];\n    var _corners$i2 = corners[i],\n        cx = _corners$i2[0],\n        cy = _corners$i2[1],\n        as = _corners$i2[2],\n        ae = _corners$i2[3];\n    var intersections = getRayCircleIntersection(cx, cy, r, ox, oy, dx, dy);\n    intersections && intersections.filter(function (pt) {\n      var pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]));\n      return pointAngle > as && pointAngle < ae;\n    }).forEach(function (pt) {\n      return points.push(pt);\n    });\n    var segmentInt = getRaySegmentIntersection(ox, oy, dx, dy, px0, py0, px1, py1);\n\n    if (!!segmentInt) {\n      points.push(segmentInt);\n    }\n  });\n  return points;\n}\n\nfunction getRectangleSegmentIntersectedByRay(x, y, w, h, ox, oy, dx, dy) {\n  return getRectangleSegments(x, y, w, h).find(function (_ref5) {\n    var sx0 = _ref5[0],\n        sy0 = _ref5[1],\n        sx1 = _ref5[2],\n        sy1 = _ref5[3];\n    return getRaySegmentIntersection(ox, oy, dx, dy, sx0, sy0, sx1, sy1);\n  });\n}\n\nfunction getRectangleSegments(x, y, w, h) {\n  return [[x, y, x + w, y], [x + w, y, x + w, y + h], [x + w, y + h, x, y + h], [x, y + h, x, y]];\n}\n\nfunction getRayCircleIntersection(cx, cy, r, ox, oy, dx, dy) {\n  // This is a shitty hack\n  return getSegmentCircleIntersections(cx, cy, r, ox, oy, dx * 999999, dy * 999999);\n}\n/**\r\n * getArrow\r\n * Get the points for a linking line between two points.\r\n * @description Draw an arrow between two points.\r\n * @param x0 The x position of the \"from\" point.\r\n * @param y0 The y position of the \"from\" point.\r\n * @param x1 The x position of the \"to\" point.\r\n * @param y1 The y position of the \"to\" point.\r\n * @param options Additional options for computing the line.\r\n * @returns [sx, sy, cx, cy, e1, e2, ae, as, ac]\r\n * @example\r\n * const arrow = getArrow(0, 0, 100, 200, {\r\n    bow: 0\r\n    stretch: .5\r\n    stretchMin: 0\r\n    stretchMax: 420\r\n    padStart: 0\r\n    padEnd: 0\r\n    flip: false\r\n    straights: true\r\n * })\r\n *\r\n * const [\r\n *  startX, startY,\r\n *  controlX, controlY,\r\n *  endX, endY,\r\n *  endAngle,\r\n *  startAngle,\r\n *  controlAngle\r\n *  ] = arrow\r\n */\n\n\nfunction getArrow(x0, y0, x1, y1, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$bow = _options.bow,\n      bow = _options$bow === void 0 ? 0 : _options$bow,\n      _options$stretch = _options.stretch,\n      stretch = _options$stretch === void 0 ? 0.5 : _options$stretch,\n      _options$stretchMin = _options.stretchMin,\n      stretchMin = _options$stretchMin === void 0 ? 0 : _options$stretchMin,\n      _options$stretchMax = _options.stretchMax,\n      stretchMax = _options$stretchMax === void 0 ? 420 : _options$stretchMax,\n      _options$padStart = _options.padStart,\n      padStart = _options$padStart === void 0 ? 0 : _options$padStart,\n      _options$padEnd = _options.padEnd,\n      padEnd = _options$padEnd === void 0 ? 0 : _options$padEnd,\n      _options$flip = _options.flip,\n      flip = _options$flip === void 0 ? false : _options$flip,\n      _options$straights = _options.straights,\n      straights = _options$straights === void 0 ? true : _options$straights;\n  var angle = getAngle(x0, y0, x1, y1);\n  var dist = getDistance(x0, y0, x1, y1);\n  var angliness = getAngliness(x0, y0, x1, y1); // Step 0 ⤜⤏ Should the arrow be straight?\n\n  if (dist < (padStart + padEnd) * 2 || // Too short\n  bow === 0 && stretch === 0 || // No bow, no stretch\n  straights && [0, 1, Infinity].includes(angliness) // 45 degree angle\n  ) {\n      // ⤜⤏ Arrow is straight! Just pad start and end points.\n      // Padding distances\n      var ps = Math.max(0, Math.min(dist - padStart, padStart));\n      var pe = Math.max(0, Math.min(dist - ps, padEnd)); // Move start point toward end point\n\n      var _projectPoint = projectPoint(x0, y0, angle, ps),\n          _px = _projectPoint[0],\n          _py = _projectPoint[1]; // Move end point toward start point\n\n\n      var _projectPoint2 = projectPoint(x1, y1, angle + Math.PI, pe),\n          _px2 = _projectPoint2[0],\n          _py2 = _projectPoint2[1]; // Get midpoint between new points\n\n\n      var _getPointBetween = getPointBetween(_px, _py, _px2, _py2, 0.5),\n          _mx = _getPointBetween[0],\n          _my = _getPointBetween[1];\n\n      return [_px, _py, _mx, _my, _px2, _py2, angle, angle, angle];\n    } // ⤜⤏ Arrow is an arc!\n  // Is the arc clockwise or counterclockwise?\n\n\n  var rot = (getSector(angle) % 2 === 0 ? 1 : -1) * (flip ? -1 : 1); // Calculate how much the line should \"bow\" away from center\n\n  var arc = bow + modulate(dist, [stretchMin, stretchMax], [1, 0], true) * stretch; // Step 1 ⤜⤏ Find padded points.\n  // Get midpoint.\n\n  var _getPointBetween2 = getPointBetween(x0, y0, x1, y1, 0.5),\n      mx = _getPointBetween2[0],\n      my = _getPointBetween2[1]; // Get control point.\n\n\n  var _getPointBetween3 = getPointBetween(x0, y0, x1, y1, 0.5 - arc),\n      cx = _getPointBetween3[0],\n      cy = _getPointBetween3[1];\n\n  var _rotatePoint = rotatePoint(cx, cy, mx, my, Math.PI / 2 * rot);\n\n  cx = _rotatePoint[0];\n  cy = _rotatePoint[1]; // Get padded start point.\n\n  var a0 = getAngle(x0, y0, cx, cy);\n\n  var _projectPoint3 = projectPoint(x0, y0, a0, padStart),\n      px0 = _projectPoint3[0],\n      py0 = _projectPoint3[1]; // Get padded end point.\n\n\n  var a1 = getAngle(x1, y1, cx, cy);\n\n  var _projectPoint4 = projectPoint(x1, y1, a1, padEnd),\n      px1 = _projectPoint4[0],\n      py1 = _projectPoint4[1]; // Step 2  ⤜⤏ Find start and end angles.\n  // Start angle\n\n\n  var as = getAngle(cx, cy, x0, y0); // End angle\n\n  var ae = getAngle(cx, cy, x1, y1); // Step 3 ⤜⤏ Find control point for padded points.\n  // Get midpoint between padded start / end points.\n\n  var _getPointBetween4 = getPointBetween(px0, py0, px1, py1, 0.5),\n      mx1 = _getPointBetween4[0],\n      my1 = _getPointBetween4[1]; // Get control point for padded start / end points.\n\n\n  var _getPointBetween5 = getPointBetween(px0, py0, px1, py1, 0.5 - arc),\n      cx1 = _getPointBetween5[0],\n      cy1 = _getPointBetween5[1];\n\n  var _rotatePoint2 = rotatePoint(cx1, cy1, mx1, my1, Math.PI / 2 * rot);\n\n  cx1 = _rotatePoint2[0];\n  cy1 = _rotatePoint2[1]; // Finally, average the two control points.\n\n  var _getPointBetween6 = getPointBetween(cx, cy, cx1, cy1, 0.5),\n      cx2 = _getPointBetween6[0],\n      cy2 = _getPointBetween6[1];\n\n  return [px0, py0, cx2, cy2, px1, py1, ae, as, angle];\n}\n\nvar PI$1 = Math.PI;\nvar MIN_ANGLE = PI$1 / 24;\n/**\r\n * getArrowBetweenBoxes\r\n * Get the points for a linking line between two boxes.\r\n * @param x0 The x-axis coordinate of the first box.\r\n * @param y0 The y-axis coordinate of the first box.\r\n * @param w0 The width of the first box.\r\n * @param h0 The height of the first box.\r\n * @param x1 The x-axis coordinate of the second box.\r\n * @param y1 The y-axis coordinate of the second box.\r\n * @param w1 The width of the second box.\r\n * @param h1 The height of the second box.\r\n * @param options\r\n */\n\nfunction getBoxToBoxArrow(x0, y0, w0, h0, x1, y1, w1, h1, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var sx, sy, ex, ey;\n  var _options = options,\n      _options$bow = _options.bow,\n      bow = _options$bow === void 0 ? 0 : _options$bow,\n      _options$stretch = _options.stretch,\n      stretch = _options$stretch === void 0 ? 0.25 : _options$stretch,\n      _options$stretchMin = _options.stretchMin,\n      stretchMin = _options$stretchMin === void 0 ? 50 : _options$stretchMin,\n      _options$stretchMax = _options.stretchMax,\n      stretchMax = _options$stretchMax === void 0 ? 420 : _options$stretchMax,\n      _options$padStart = _options.padStart,\n      padStart = _options$padStart === void 0 ? 0 : _options$padStart,\n      _options$padEnd = _options.padEnd,\n      padEnd = _options$padEnd === void 0 ? 20 : _options$padEnd,\n      _options$flip = _options.flip,\n      flip = _options$flip === void 0 ? false : _options$flip,\n      _options$straights = _options.straights,\n      straights = _options$straights === void 0 ? true : _options$straights;\n  var px0 = x0 - padStart,\n      py0 = y0 - padStart,\n      pw0 = w0 + padStart * 2,\n      ph0 = h0 + padStart * 2,\n      px1 = x1 - padEnd,\n      py1 = y1 - padEnd,\n      pw1 = w1 + padEnd * 2,\n      ph1 = h1 + padEnd * 2,\n      cx0 = x0 + w0 / 2,\n      cy0 = y0 + h0 / 2,\n      cx1 = x1 + w1 / 2,\n      cy1 = y1 + h1 / 2; // Angle between centers\n\n  var angle = normalizeAngle(getAngle(cx0, cy0, cx1, cy1)); // Distance between centers\n\n  var distance = getDistance(cx0, cy0, cx1, cy1); // Perfect overlap, no arrow.\n\n  if (distance === 0) {\n    var _sx = cx0,\n        _sy = py0;\n    var _ex = cx1,\n        _ey = py1;\n\n    var _getPointBetween = getPointBetween(_sx, _sy, _ex, _ey, 0.5),\n        cx = _getPointBetween[0],\n        cy = _getPointBetween[1];\n\n    var ca = getAngle(_sx, _sy, _ex, _ey);\n    return [_sx, _sy, cx, cy, _ex, _ey, ca, ca, ca];\n  } // Rotation of the arrow, clockwise or anticlockwise\n\n\n  var rot = (getSector(angle) % 2 === 0 ? -1 : 1) * (flip ? -1 : 1); // How cardinal is the angle? 0 = 45deg, 1 = 90deg\n\n  var card = getIntermediate(angle);\n  if (card < 1 && card > 0.85) card = 0.99; // Are the boxes colliding / overlapping?\n\n  var isColliding = doRectanglesCollide(px0, py0, pw0, ph0, px1, py1, pw1, ph1); // Direct line between boxes\n\n  var _getLineBetweenRounde = getLineBetweenRoundedRectangles(px0, py0, pw0, ph0, padStart, px1, py1, pw1, ph1, padEnd),\n      dix0 = _getLineBetweenRounde[0],\n      diy0 = _getLineBetweenRounde[1],\n      dix1 = _getLineBetweenRounde[2],\n      diy1 = _getLineBetweenRounde[3]; // Length of the direct line between boxes\n\n\n  var distanceBetween = getDistance(dix0, diy0, dix1, diy1);\n  /* ------------- RETURN A STRAIGHT ARROW ------------ */\n  // Should we just draw a straight line?\n\n  if (!isColliding && straights && card % 0.5 === 0) {\n    var _getPointBetween2 = getPointBetween(dix0, diy0, dix1, diy1, 0.5),\n        mpdx = _getPointBetween2[0],\n        mpdy = _getPointBetween2[1];\n\n    return [dix0, diy0, mpdx, mpdy, dix1, diy1, angle, angle - PI$1, angle];\n  }\n  /* -------------- RETURN A CURVED ARROW ------------- */\n  // How much are the two boxes overlapping?\n\n\n  var overlapEffect = isColliding ? modulate(distanceBetween, [0, distance], [0, 1], true) : 0; // How far away are the two boxes?\n\n  var distEffect = 1 - distanceBetween / distance; // How much should the stretch impact the arc?\n\n  var stretchEffect = modulate(distanceBetween, [stretchMin, stretchMax], [1, 0], true); // What should the curved line's arc be?\n\n  var arc = bow + stretchEffect * stretch; // How much should the angle's intermediacy (45degree-ness) affect the angle?\n\n  var angleOffset = modulate(card * card, // a better curve here?\n  [0, 1], [PI$1 * 0.125, 0], true);\n  var distOffset = isColliding ? PI$1 * 0.5 * card : modulate(distEffect, // a better curve here?\n  [0.75, 1], [0, PI$1 * 0.5], true) * card;\n  var combinedOffset = distOffset + angleOffset * (isColliding ? 1 - overlapEffect : 1);\n  /* ----------------- STARTING POINT ----------------- */\n  // Angle of the first box\n\n  var finalAngle0 = overlapEffect >= 0.5 ? angle + PI$1 * rot : angle + Math.max(MIN_ANGLE, combinedOffset) * rot; // Deltas of starting angle\n\n  var _getDelta = getDelta(finalAngle0),\n      dx0 = _getDelta[0],\n      dy0 = _getDelta[1]; // Get ray intersection with rounded rectangle\n\n\n  var _getRayRoundedRectang = getRayRoundedRectangleIntersection(cx0, cy0, dx0, dy0, px0, py0, pw0, ph0, padStart),\n      _getRayRoundedRectang2 = _getRayRoundedRectang[0],\n      tsx = _getRayRoundedRectang2[0],\n      tsy = _getRayRoundedRectang2[1]; // Get midpoint of startingintersected segment\n\n\n  var startSeg = getRectangleSegmentIntersectedByRay(px0, py0, pw0, ph0, cx0, cy0, dx0, dy0);\n  if (!startSeg) throw Error; // Find start point (quarter way between segment midpoint and ray intersection)\n\n  var ssx0 = startSeg[0],\n      ssy0 = startSeg[1],\n      ssx1 = startSeg[2],\n      ssy1 = startSeg[3];\n\n  var _getPointBetween3 = getPointBetween(ssx0, ssy0, ssx1, ssy1, 0.5),\n      smpx = _getPointBetween3[0],\n      smpy = _getPointBetween3[1];\n\n  var _getPointBetween4 = getPointBetween(tsx, tsy, smpx, smpy, isColliding ? Math.max(overlapEffect, 0.15) : 0.15);\n\n  sx = _getPointBetween4[0];\n  sy = _getPointBetween4[1];\n  arc *= 1 + (Math.max(-2, Math.min(distEffect, 2)) * card - overlapEffect) / 2;\n\n  if (isColliding) {\n    arc = arc < 0 ? Math.min(arc, -0.5) : Math.max(arc, 0.5);\n  }\n  /* ------------------ ENDING POINT ------------------ */\n\n\n  if (overlapEffect >= 0.5) {\n    // If overlapping, use the same angle as the start\n    var rayAngle = getAngle(cx0, cy0, smpx, smpy);\n\n    var _getDelta2 = getDelta(rayAngle),\n        dx1 = _getDelta2[0],\n        dy1 = _getDelta2[1];\n\n    var _getRayRoundedRectang3 = getRayRoundedRectangleIntersection(cx1, cy1, dx1, dy1, px1, py1, pw1, ph1, padEnd);\n\n    var _getRayRoundedRectang4 = _getRayRoundedRectang3[0];\n    ex = _getRayRoundedRectang4[0];\n    ey = _getRayRoundedRectang4[1];\n  } else {\n    // Calculate an angle based on distance, overlap and intermediacy\n    var distOffset1 = modulate(distEffect, [0.75, 1], [0, 1], true);\n    var overlapEffect1 = isColliding ? modulate(overlapEffect, [0, 1], [0, PI$1 / 8], true) : 0;\n    var cardEffect1 = modulate(card * distOffset1, [0, 1], [0, PI$1 / 16], true);\n\n    var _combinedOffset = distEffect * (PI$1 / 12) + (cardEffect1 + overlapEffect1) + (distOffset + angleOffset) / 2;\n\n    var finalAngle1 = overlapEffect >= 0.5 ? angle + PI$1 * rot : angle + PI$1 - Math.max(_combinedOffset, MIN_ANGLE) * rot; // Deltas of ending angle\n\n    var _getDelta3 = getDelta(finalAngle1),\n        _dx = _getDelta3[0],\n        _dy = _getDelta3[1]; // Get ray intersection with ending rounded rectangle\n\n\n    var _getRayRoundedRectang5 = getRayRoundedRectangleIntersection(cx1, cy1, _dx, _dy, px1, py1, pw1, ph1, padEnd),\n        _getRayRoundedRectang6 = _getRayRoundedRectang5[0],\n        tex = _getRayRoundedRectang6[0],\n        tey = _getRayRoundedRectang6[1]; // Get midpoint of ending intersected segment\n\n\n    var endSeg = getRectangleSegmentIntersectedByRay(px1, py1, pw1, ph1, cx1, cy1, _dx, _dy);\n    if (!endSeg) throw Error;\n    var sex0 = endSeg[0],\n        sey0 = endSeg[1],\n        sex1 = endSeg[2],\n        sey1 = endSeg[3];\n\n    var _getPointBetween5 = getPointBetween(sex0, sey0, sex1, sey1, 0.5),\n        empx = _getPointBetween5[0],\n        empy = _getPointBetween5[1];\n\n    var _getPointBetween6 = getPointBetween(tex, tey, empx, empy, 0.25 + overlapEffect * 0.25);\n\n    ex = _getPointBetween6[0];\n    ey = _getPointBetween6[1];\n  }\n  /* ------------------- DRAW ARROWS ------------------ */\n  // Get midpoints.\n\n\n  var _getPointBetween7 = getPointBetween(sx, sy, ex, ey, 0.5),\n      mx1 = _getPointBetween7[0],\n      my1 = _getPointBetween7[1];\n\n  var _getPointBetween8 = getPointBetween(sx, sy, ex, ey, Math.max(-1, Math.min(1, 0.5 + arc)) // Clamped to 2\n  ),\n      tix = _getPointBetween8[0],\n      tiy = _getPointBetween8[1]; // Rotate them (these are our two potential corners)\n\n\n  var _rotatePoint = rotatePoint(tix, tiy, mx1, my1, PI$1 / 2 * rot),\n      cixA = _rotatePoint[0],\n      ciyA = _rotatePoint[1];\n\n  var _rotatePoint2 = rotatePoint(tix, tiy, mx1, my1, PI$1 / 2 * -rot),\n      cixB = _rotatePoint2[0],\n      ciyB = _rotatePoint2[1]; // If we're colliding, pick the furthest corner from the end point.\n\n\n  var _ref = isColliding && getDistance(cixA, ciyA, cx1, cy1) < getDistance(cixB, ciyB, cx1, cy1) ? [cixB, ciyB] : [cixA, ciyA],\n      cix = _ref[0],\n      ciy = _ref[1]; // Start and end angles\n\n\n  var as = getAngle(cix, ciy, sx, sy);\n  var ae = getAngle(cix, ciy, ex, ey);\n  return [sx, sy, cix, ciy, ex, ey, ae, as, getAngle(sx, sy, ex, ey)];\n}\n\nexport { getArrow, getBoxToBoxArrow };","map":{"version":3,"sources":["../src/lib/utils.ts","../src/lib/getArrow.ts","../src/lib/getBoxToBoxArrow.ts"],"names":["PI","Math","modulate","value","rangeA","rangeB","clamp","fromLow","fromHigh","toLow","toHigh","result","rotatePoint","x","y","cx","cy","angle","s","c","px","py","nx","ny","getDistance","x0","y0","x1","y1","getAngle","projectPoint","a","d","getPointBetween","getSector","getAngliness","doRectanglesCollide","w0","h0","w1","h1","getSegmentCircleIntersections","r","v1","v2","b","isNaN","u1","u2","retP1","retP2","ret","normalizeAngle","radians","getRaySegmentIntersection","dx","dy","getDelta","getIntermediate","getLineBetweenRoundedRectangles","r0","r1","cy0","cx1","cy1","di0x","di0y","getRayRoundedRectangleIntersection","di1x","di1y","cx0","ox","oy","w","h","mx","my","rx","ry","mrx","mry","segments","corners","points","px0","py0","px1","py1","segment","as","ae","intersections","getRayCircleIntersection","pointAngle","pt","segmentInt","getRectangleSegmentIntersectedByRay","sx0","sy0","sx1","sy1","getRectangleSegments","getArrow","options","bow","stretch","stretchMin","stretchMax","padStart","padEnd","flip","straights","dist","angliness","ps","pe","rot","arc","a0","a1","mx1","my1","cx2","cy2","MIN_ANGLE","getBoxToBoxArrow","pw0","ph0","pw1","ph1","distance","sx","sy","ex","ey","ca","card","isColliding","dix0","diy0","dix1","diy1","distanceBetween","mpdx","mpdy","overlapEffect","distEffect","stretchEffect","angleOffset","distOffset","combinedOffset","finalAngle0","dx0","dy0","tsx","tsy","startSeg","ssx0","ssy0","ssx1","ssy1","smpx","smpy","rayAngle","dx1","dy1","distOffset1","overlapEffect1","cardEffect1","finalAngle1","tex","tey","endSeg","sex0","sey0","sex1","sey1","empx","empy","tix","tiy","cixA","ciyA","cixB","ciyB","cix","ciy"],"mappings":"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","sourcesContent":["const PI = Math.PI\n\n/**\n * Modulate a value between two ranges.\n * @param value\n * @param rangeA from [low, high]\n * @param rangeB to [low, high]\n * @param clamp\n */\nexport function modulate(\n  value: number,\n  rangeA: number[],\n  rangeB: number[],\n  clamp = false\n) {\n  const [fromLow, fromHigh] = rangeA\n  const [toLow, toHigh] = rangeB\n  const result =\n    toLow + ((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow)\n  if (clamp === true) {\n    if (toLow < toHigh) {\n      if (result < toLow) {\n        return toLow\n      }\n      if (result > toHigh) {\n        return toHigh\n      }\n    } else {\n      if (result > toLow) {\n        return toLow\n      }\n      if (result < toHigh) {\n        return toHigh\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Rotate a point around a center.\n * @param x The x-axis coordinate of the point.\n * @param y The y-axis coordinate of the point.\n * @param cx The x-axis coordinate of the point to rotate round.\n * @param cy The y-axis coordinate of the point to rotate round.\n * @param angle The distance (in radians) to rotate.\n */\nexport function rotatePoint(\n  x: number,\n  y: number,\n  cx: number,\n  cy: number,\n  angle: number\n) {\n  const s = Math.sin(angle)\n  const c = Math.cos(angle)\n\n  const px = x - cx\n  const py = y - cy\n\n  const nx = px * c - py * s\n  const ny = px * s + py * c\n\n  return [nx + cx, ny + cy]\n}\n\n/**\n * Get the distance between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getDistance(x0: number, y0: number, x1: number, y1: number) {\n  return Math.hypot(y1 - y0, x1 - x0)\n}\n\n/**\n * Get an angle (radians) between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getAngle(x0: number, y0: number, x1: number, y1: number) {\n  return Math.atan2(y1 - y0, x1 - x0)\n}\n\n/**\n * Move a point in an angle by a distance.\n * @param x0\n * @param y0\n * @param a angle (radians)\n * @param d distance\n */\nexport function projectPoint(x0: number, y0: number, a: number, d: number) {\n  return [Math.cos(a) * d + x0, Math.sin(a) * d + y0]\n}\n\n/**\n * Get a point between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n * @param d Normalized\n */\nexport function getPointBetween(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  d = 0.5\n) {\n  return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d]\n}\n\n/**\n * Get the sector of an angle (e.g. quadrant, octant)\n * @param a The angle to check.\n * @param s The number of sectors to check.\n */\nexport function getSector(a: number, s = 8) {\n  return Math.floor(s * (0.5 + ((a / (PI * 2)) % s)))\n}\n\n/**\n * Get a normal value representing how close two points are from being at a 45 degree angle.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getAngliness(x0: number, y0: number, x1: number, y1: number) {\n  return Math.abs((x1 - x0) / 2 / ((y1 - y0) / 2))\n}\n\n/**\n * Get the points at which an ellipse intersects a rectangle.\n * @param x\n * @param y\n * @param w\n * @param h\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param angle\n */\nexport function getEllipseRectangleIntersectionPoints(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  angle: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getEllipseSegmentIntersections(\n      px0,\n      py0,\n      px1,\n      py1,\n      cx,\n      cy,\n      rx,\n      ry,\n      angle\n    )\n\n    if (ints.length > 0) {\n      points.push(...ints)\n    }\n  }\n\n  points = points.sort(([x0, y0], [x1, y1]) => {\n    return Math.sin(getAngle(cx, cy, x0, y0) - getAngle(cx, cy, x1, y1)) > 0\n      ? -1\n      : 1\n  })\n\n  return points\n}\n\n/**\n * Find the point(s) where a line segment intersects an ellipse.\n * @param x0 The x-axis coordinate of the line's start point.\n * @param y0 The y-axis coordinate of the line's start point.\n * @param x1 The x-axis coordinate of the line's end point.\n * @param y1 The y-axis coordinate of the line's end point.\n * @param cx The x-axis (horizontal) coordinate of the ellipse's center.\n * @param cy The y-axis (vertical) coordinate of the ellipse's center.\n * @param rx The ellipse's major-axis radius. Must be non-negative.\n * @param ry The ellipse's minor-axis radius. Must be non-negative.\n * @param rotation The rotation of the ellipse, expressed in radians.\n * @param segment_only When true, will test the segment as a line (of infinite length).\n */\nexport function getEllipseSegmentIntersections(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  rotation = 0,\n  segment_only = true\n) {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || (x0 === x1 && y0 === y1)) {\n    return []\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points.\n  if (rotation !== 0) {\n    ;[x0, y0] = rotatePoint(x0, y0, cx, cy, -rotation)\n    ;[x1, y1] = rotatePoint(x1, y1, cx, cy, -rotation)\n  }\n\n  // Translate so the ellipse is centered at the origin.\n  x0 -= cx\n  y0 -= cy\n  x1 -= cx\n  y1 -= cy\n\n  // Calculate the quadratic parameters.\n  var A = ((x1 - x0) * (x1 - x0)) / rx / rx + ((y1 - y0) * (y1 - y0)) / ry / ry\n  var B = (2 * x0 * (x1 - x0)) / rx / rx + (2 * y0 * (y1 - y0)) / ry / ry\n  var C = (x0 * x0) / rx / rx + (y0 * y0) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  var tValues: number[] = []\n\n  // Calculate the discriminant.\n  var discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    // Two real solutions.\n    tValues.push((-B + Math.sqrt(discriminant)) / 2 / A)\n    tValues.push((-B - Math.sqrt(discriminant)) / 2 / A)\n  }\n\n  return (\n    tValues\n      // Filter to only points that are on the segment.\n      .filter(t => !segment_only || (t >= 0 && t <= 1))\n      // Solve for points.\n      .map(t => [x0 + (x1 - x0) * t + cx, y0 + (y1 - y0) * t + cy])\n      // Counter-rotate points\n      .map(p =>\n        rotation === 0 ? p : rotatePoint(p[0], p[1], cx, cy, rotation)\n      )\n  )\n}\n\n/**\n * Check whether two rectangles will collide (overlap).\n * @param x0 The x-axis coordinate of the first rectangle.\n * @param y0 The y-axis coordinate of the first rectangle.\n * @param w0 The width of the first rectangle.\n * @param h0 The height of the first rectangle.\n * @param x1 The x-axis coordinate of the second rectangle.\n * @param y1 The y-axis coordinate of the second rectangle.\n * @param w1 The width of the second rectangle.\n * @param h1 The height of the second rectangle.\n */\nexport function doRectanglesCollide(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number\n) {\n  return !(x0 >= x1 + w1 || x1 >= x0 + w0 || y0 >= y1 + h1 || y1 >= y0 + h0)\n}\n\n/**\n * Find the point(s) where a segment intersects a rectangle.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of the segment's starting point.\n * @param x1 The x-axis coordinate of the segment's ending point.\n * @param y1 The y-axis coordinate of the segment's ending point.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n */\nexport function getSegmentRectangleIntersectionPoints(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getSegmentSegmentIntersection(\n      px0,\n      py0,\n      px1,\n      py1,\n      x0,\n      y0,\n      x1,\n      y1\n    )\n    if (ints) {\n      points.push(ints)\n    }\n  }\n\n  return points\n}\n\n/**\n * Find the point, if any, where two segments intersect.\n * @param x0 The x-axis coordinate of the first segment's starting point.\n * @param y0 The y-axis coordinate of the first segment's starting point.\n * @param x1 The x-axis coordinate of the first segment's ending point.\n * @param y1 The y-axis coordinate of the first segment's ending point.\n * @param x2 The x-axis coordinate of the second segment's starting point.\n * @param y2 The y-axis coordinate of the second segment's starting point.\n * @param x3 The x-axis coordinate of the second segment's ending point.\n * @param y3 The y-axis coordinate of the second segment's ending point.\n */\nexport function getSegmentSegmentIntersection(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number\n) {\n  const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0)\n  const numeA = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2)\n  const numeB = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2)\n\n  if (denom === 0) {\n    if (numeA === 0 && numeB === 0) {\n      return undefined // Colinear\n    }\n    return undefined // Parallel\n  }\n\n  const uA = numeA / denom\n  const uB = numeB / denom\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    return [x0 + uA * (x1 - x0), y0 + uA * (y1 - y0)]\n  }\n\n  return undefined // No intersection\n}\n\n/**\n * Get the intersection points between a line segment and a rectangle with rounded corners.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of the segment's ending point.\n * @param x1 The delta-x of the ray.\n * @param y1 The delta-y of the ray.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n * @param r The corner radius of the rectangle.\n */\nexport function getSegmentRoundedRectangleIntersectionPoints(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const mx = x + w,\n    my = y + h,\n    rx = x + r,\n    ry = y + r,\n    mrx = x + w - r,\n    mry = y + h - r\n\n  const segments = [\n    [x, mry, x, ry, x, y],\n    [rx, y, mrx, y, mx, y],\n    [mx, ry, mx, mry, mx, my],\n    [mrx, my, rx, my, x, my],\n  ]\n\n  const corners = [\n    [rx, ry, PI, PI * 1.5],\n    [mrx, ry, PI * 1.5, PI * 2],\n    [mrx, mry, 0, PI * 0.5],\n    [rx, mry, PI * 0.5, PI],\n  ]\n\n  let points: number[][] = []\n\n  segments.forEach((segment, i) => {\n    const [px0, py0, px1, py1] = segment\n    const [cx, cy, as, ae] = corners[i]\n\n    getSegmentCircleIntersections(cx, cy, r, x0, y0, x1, y1)\n      .filter(pt => {\n        const pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]))\n        return pointAngle > as && pointAngle < ae\n      })\n      .forEach(pt => points.push(pt))\n\n    const segmentInt = getSegmentSegmentIntersection(\n      x0,\n      y0,\n      x1,\n      y1,\n      px0,\n      py0,\n      px1,\n      py1\n    )\n\n    if (!!segmentInt) {\n      points.push(segmentInt)\n    }\n  })\n\n  return points\n}\n\n/**\n * Get the point(s) where a line segment intersects a circle.\n * @param cx The x-axis coordinate of the circle's center.\n * @param cy The y-axis coordinate of the circle's center.\n * @param r The circle's radius.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of ththe segment's ending point.\n * @param x1 The delta-x of the ray.\n * @param y1 The delta-y of the ray.\n */\nexport function getSegmentCircleIntersections(\n  cx: number,\n  cy: number,\n  r: number,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) {\n  var b: number,\n    c: number,\n    d: number,\n    u1: number,\n    u2: number,\n    ret: number[][],\n    retP1: number[],\n    retP2: number[],\n    v1 = [x1 - x0, y1 - y0],\n    v2 = [x0 - cx, y0 - cy]\n\n  b = v1[0] * v2[0] + v1[1] * v2[1]\n  c = 2 * (v1[0] * v1[0] + v1[1] * v1[1])\n  b *= -2\n  d = Math.sqrt(b * b - 2 * c * (v2[0] * v2[0] + v2[1] * v2[1] - r * r))\n  if (isNaN(d)) {\n    // no intercept\n    return []\n  }\n  u1 = (b - d) / c // these represent the unit distance of point one and two on the line\n  u2 = (b + d) / c\n  retP1 = [] // return points\n  retP2 = []\n  ret = [] // return array\n\n  if (u1 <= 1 && u1 >= 0) {\n    // add point if on the line segment\n    retP1[0] = x0 + v1[0] * u1\n    retP1[1] = y0 + v1[1] * u1\n    ret[0] = retP1\n  }\n\n  if (u2 <= 1 && u2 >= 0) {\n    // second add point if on the line segment\n    retP2[0] = x0 + v1[0] * u2\n    retP2[1] = y0 + v1[1] * u2\n    ret[ret.length] = retP2\n  }\n\n  return ret\n}\n\n/**\n * Normalize an angle (in radians)\n * @param radians The radians quantity to normalize.\n */\nexport function normalizeAngle(radians: number) {\n  return radians - PI * 2 * Math.floor(radians / (PI * 2))\n}\n\n/**\n *\n * @param x The x-axis coordinate of the ray's origin.\n * @param y The y-axis coordinate of the ray's origin.\n * @param w\n * @param h\n * @param x0\n * @param y0\n * @param x1\n * @param y1\n */\nexport function getRayRectangleIntersectionPoints(\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getRaySegmentIntersection(ox, oy, dx, dy, px0, py0, px1, py1)\n    if (ints) {\n      points.push(ints)\n    }\n  }\n\n  return points\n}\n\n/**\n * Get the point at which a ray intersects a segment.\n * @param x The x-axis coordinate of the ray's origin.\n * @param y The y-axis coordinate of the ray's origin.\n * @param dx The x-axis delta of the angle.\n * @param dy The y-axis delta of the angle.\n * @param x0 The x-axis coordinate of the segment's start point.\n * @param y0 The y-axis coordinate of the segment's start point.\n * @param x1 The x-axis coordinate of the segment's end point.\n * @param y1 The y-axis coordinate of the segment's end point.\n */\nexport function getRaySegmentIntersection(\n  x: number,\n  y: number,\n  dx: number,\n  dy: number,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) {\n  let r: number, s: number, d: number\n\n  if (dy * (x1 - x0) !== dx * (y1 - y0)) {\n    d = dx * (y1 - y0) - dy * (x1 - x0)\n    if (d !== 0) {\n      r = ((y - y0) * (x1 - x0) - (x - x0) * (y1 - y0)) / d\n      s = ((y - y0) * dx - (x - x0) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return [x + r * dx, y + r * dy]\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * Get the normalized delta (x and y) for an angle.\n * @param angle The angle in radians\n */\nexport function getDelta(angle: number) {\n  return [Math.cos(angle), Math.sin(angle)]\n}\n\nexport function getIntermediate(angle: number) {\n  return Math.abs(Math.abs(angle % (PI / 2)) - PI / 4) / (PI / 4)\n}\n\n/**\n * Get a line between two rounded rectangles.\n * @param x0\n * @param y0\n * @param w0\n * @param h0\n * @param r0\n * @param x1\n * @param y1\n * @param w1\n * @param h1\n * @param r1\n */\nexport function getLineBetweenRoundedRectangles(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  r0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  r1: number\n) {\n  const cx0 = x0 + w0 / 2,\n    cy0 = y0 + h0 / 2,\n    cx1 = x1 + w1 / 2,\n    cy1 = y1 + h1 / 2,\n    [[di0x, di0y]] = getRayRoundedRectangleIntersection(\n      cx0,\n      cy0,\n      cx1 - cx0,\n      cy1 - cy0,\n      x0,\n      y0,\n      w0,\n      h0,\n      r0\n    ) || [[cx0, cy0]],\n    [[di1x, di1y]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      cx0 - cx1,\n      cy0 - cy1,\n      x1,\n      y1,\n      w1,\n      h1,\n      r1\n    ) || [[cx1, cy1]]\n\n  return [di0x, di0y, di1x, di1y]\n}\n\n/**\n * Get the intersection points between a ray and a rectangle with rounded corners.\n * @param ox The x-axis coordinate of the ray's origin.\n * @param oy The y-axis coordinate of the ray's origin.\n * @param dx The delta-x of the ray.\n * @param dy The delta-y of the ray.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n * @param r The corner radius of the rectangle.\n */\nexport function getRayRoundedRectangleIntersection(\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const mx = x + w,\n    my = y + h,\n    rx = x + r - 1,\n    ry = y + r - 1,\n    mrx = x + w - r + 1,\n    mry = y + h - r + 1\n\n  const segments = [\n    [x, mry, x, ry],\n    [rx, y, mrx, y],\n    [mx, ry, mx, mry],\n    [mrx, my, rx, my],\n  ]\n\n  const corners = [\n    [rx, ry, Math.PI, Math.PI * 1.5],\n    [mrx, ry, Math.PI * 1.5, Math.PI * 2],\n    [mrx, mry, 0, Math.PI * 0.5],\n    [rx, mry, Math.PI * 0.5, Math.PI],\n  ]\n\n  let points: number[][] = []\n\n  segments.forEach((segment, i) => {\n    const [px0, py0, px1, py1] = segment\n    const [cx, cy, as, ae] = corners[i]\n\n    const intersections = getRayCircleIntersection(cx, cy, r, ox, oy, dx, dy)\n\n    intersections &&\n      intersections\n        .filter(pt => {\n          const pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]))\n          return pointAngle > as && pointAngle < ae\n        })\n        .forEach(pt => points.push(pt))\n\n    const segmentInt = getRaySegmentIntersection(\n      ox,\n      oy,\n      dx,\n      dy,\n      px0,\n      py0,\n      px1,\n      py1\n    )\n\n    if (!!segmentInt) {\n      points.push(segmentInt)\n    }\n  })\n\n  return points\n}\n\nexport function getRectangleSegmentIntersectedByRay(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number\n) {\n  return getRectangleSegments(x, y, w, h).find(([sx0, sy0, sx1, sy1]) =>\n    getRaySegmentIntersection(ox, oy, dx, dy, sx0, sy0, sx1, sy1)\n  )\n}\n\nexport function getRectangleSegments(\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  return [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]\n}\n\nexport function getRoundedRectangleSegments(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const rx = x + r,\n    ry = y + r,\n    mx = x + w,\n    my = y + h,\n    mrx = x + w - r,\n    mry = y + h - r\n\n  return [\n    [x, mry, x, ry, x, y],\n    [rx, y, mrx, y, mx, y],\n    [mx, ry, mx, mry, mx, my],\n    [mrx, my, rx, my, x, my],\n  ]\n}\n\nexport function getRayCircleIntersection(\n  cx: number,\n  cy: number,\n  r: number,\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number\n) {\n  // This is a shitty hack\n  return getSegmentCircleIntersections(\n    cx,\n    cy,\n    r,\n    ox,\n    oy,\n    dx * 999999,\n    dy * 999999\n  )\n}\n","import {\n  getAngle,\n  getDistance,\n  getAngliness,\n  projectPoint,\n  getPointBetween,\n  getSector,\n  rotatePoint,\n  modulate,\n} from \"./utils\"\n\nexport type ArrowOptions = {\n  bow?: number\n  stretchMin?: number\n  stretchMax?: number\n  stretch?: number\n  padStart?: number\n  padEnd?: number\n  flip?: boolean\n  straights?: boolean\n}\n\n/**\n * getArrow\n * Get the points for a linking line between two points.\n * @description Draw an arrow between two points.\n * @param x0 The x position of the \"from\" point.\n * @param y0 The y position of the \"from\" point.\n * @param x1 The x position of the \"to\" point.\n * @param y1 The y position of the \"to\" point.\n * @param options Additional options for computing the line.\n * @returns [sx, sy, cx, cy, e1, e2, ae, as, ac]\n * @example\n * const arrow = getArrow(0, 0, 100, 200, {\n    bow: 0\n    stretch: .5\n    stretchMin: 0\n    stretchMax: 420\n    padStart: 0\n    padEnd: 0\n    flip: false\n    straights: true\n * })\n * \n * const [\n *  startX, startY, \n *  controlX, controlY, \n *  endX, endY, \n *  endAngle, \n *  startAngle,\n *  controlAngle\n *  ] = arrow\n */\nexport default function getArrow(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  options: ArrowOptions = {} as ArrowOptions\n): number[] {\n  const {\n    bow = 0,\n    stretch = 0.5,\n    stretchMin = 0,\n    stretchMax = 420,\n    padStart = 0,\n    padEnd = 0,\n    flip = false,\n    straights = true,\n  } = options\n\n  const angle = getAngle(x0, y0, x1, y1)\n  const dist = getDistance(x0, y0, x1, y1)\n  const angliness = getAngliness(x0, y0, x1, y1)\n\n  // Step 0 ⤜⤏ Should the arrow be straight?\n\n  if (\n    dist < (padStart + padEnd) * 2 || // Too short\n    (bow === 0 && stretch === 0) || // No bow, no stretch\n    (straights && [0, 1, Infinity].includes(angliness)) // 45 degree angle\n  ) {\n    // ⤜⤏ Arrow is straight! Just pad start and end points.\n\n    // Padding distances\n    const ps = Math.max(0, Math.min(dist - padStart, padStart))\n    const pe = Math.max(0, Math.min(dist - ps, padEnd))\n\n    // Move start point toward end point\n    let [px0, py0] = projectPoint(x0, y0, angle, ps)\n\n    // Move end point toward start point\n    let [px1, py1] = projectPoint(x1, y1, angle + Math.PI, pe)\n\n    // Get midpoint between new points\n    const [mx, my] = getPointBetween(px0, py0, px1, py1, 0.5)\n\n    return [px0, py0, mx, my, px1, py1, angle, angle, angle]\n  }\n\n  // ⤜⤏ Arrow is an arc!\n\n  // Is the arc clockwise or counterclockwise?\n  let rot = (getSector(angle) % 2 === 0 ? 1 : -1) * (flip ? -1 : 1)\n\n  // Calculate how much the line should \"bow\" away from center\n  const arc =\n    bow + modulate(dist, [stretchMin, stretchMax], [1, 0], true) * stretch\n\n  // Step 1 ⤜⤏ Find padded points.\n\n  // Get midpoint.\n  const [mx, my] = getPointBetween(x0, y0, x1, y1, 0.5)\n\n  // Get control point.\n  let [cx, cy] = getPointBetween(x0, y0, x1, y1, 0.5 - arc)\n\n    // Rotate control point (clockwise or counterclockwise).\n  ;[cx, cy] = rotatePoint(cx, cy, mx, my, (Math.PI / 2) * rot)\n\n  // Get padded start point.\n  const a0 = getAngle(x0, y0, cx, cy)\n  const [px0, py0] = projectPoint(x0, y0, a0, padStart)\n\n  // Get padded end point.\n  const a1 = getAngle(x1, y1, cx, cy)\n  const [px1, py1] = projectPoint(x1, y1, a1, padEnd)\n\n  // Step 2  ⤜⤏ Find start and end angles.\n\n  // Start angle\n  const as = getAngle(cx, cy, x0, y0)\n\n  // End angle\n  const ae = getAngle(cx, cy, x1, y1)\n\n  // Step 3 ⤜⤏ Find control point for padded points.\n\n  // Get midpoint between padded start / end points.\n  const [mx1, my1] = getPointBetween(px0, py0, px1, py1, 0.5)\n\n  // Get control point for padded start / end points.\n  let [cx1, cy1] = getPointBetween(px0, py0, px1, py1, 0.5 - arc)\n\n    // Rotate control point (clockwise or counterclockwise).\n  ;[cx1, cy1] = rotatePoint(cx1, cy1, mx1, my1, (Math.PI / 2) * rot)\n\n  // Finally, average the two control points.\n  let [cx2, cy2] = getPointBetween(cx, cy, cx1, cy1, 0.5)\n\n  return [px0, py0, cx2, cy2, px1, py1, ae, as, angle]\n}\n","import {\n  getDistance,\n  getSector,\n  modulate,\n  getDelta,\n  getAngle,\n  rotatePoint,\n  getPointBetween,\n  doRectanglesCollide,\n  getIntermediate,\n  getLineBetweenRoundedRectangles,\n  normalizeAngle,\n  getRayRoundedRectangleIntersection,\n  getRectangleSegmentIntersectedByRay,\n} from \"./utils\"\n\nexport type ArrowOptions = {\n  bow?: number\n  stretchMin?: number\n  stretchMax?: number\n  stretch?: number\n  padStart?: number\n  padEnd?: number\n  flip?: boolean\n  straights?: boolean\n}\n\nconst PI = Math.PI\nconst MIN_ANGLE = PI / 24\n\n/**\n * getArrowBetweenBoxes\n * Get the points for a linking line between two boxes.\n * @param x0 The x-axis coordinate of the first box.\n * @param y0 The y-axis coordinate of the first box.\n * @param w0 The width of the first box.\n * @param h0 The height of the first box.\n * @param x1 The x-axis coordinate of the second box.\n * @param y1 The y-axis coordinate of the second box.\n * @param w1 The width of the second box.\n * @param h1 The height of the second box.\n * @param options\n */\nexport default function getBoxToBoxArrow(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  options: ArrowOptions = {} as ArrowOptions\n) {\n  let sx: number, sy: number, ex: number, ey: number\n\n  const {\n    bow = 0,\n    stretch = 0.25,\n    stretchMin = 50,\n    stretchMax = 420,\n    padStart = 0,\n    padEnd = 20,\n    flip = false,\n    straights = true,\n  } = options\n\n  const px0 = x0 - padStart,\n    py0 = y0 - padStart,\n    pw0 = w0 + padStart * 2,\n    ph0 = h0 + padStart * 2,\n    px1 = x1 - padEnd,\n    py1 = y1 - padEnd,\n    pw1 = w1 + padEnd * 2,\n    ph1 = h1 + padEnd * 2,\n    cx0 = x0 + w0 / 2,\n    cy0 = y0 + h0 / 2,\n    cx1 = x1 + w1 / 2,\n    cy1 = y1 + h1 / 2\n\n  // Angle between centers\n  const angle = normalizeAngle(getAngle(cx0, cy0, cx1, cy1))\n\n  // Distance between centers\n  const distance = getDistance(cx0, cy0, cx1, cy1)\n\n  // Perfect overlap, no arrow.\n  if (distance === 0) {\n    const [sx, sy] = [cx0, py0]\n    const [ex, ey] = [cx1, py1]\n    const [cx, cy] = getPointBetween(sx, sy, ex, ey, 0.5)\n    const ca = getAngle(sx, sy, ex, ey)\n    return [sx, sy, cx, cy, ex, ey, ca, ca, ca]\n  }\n\n  // Rotation of the arrow, clockwise or anticlockwise\n  const rot = (getSector(angle) % 2 === 0 ? -1 : 1) * (flip ? -1 : 1)\n\n  // How cardinal is the angle? 0 = 45deg, 1 = 90deg\n  let card = getIntermediate(angle)\n\n  if (card < 1 && card > 0.85) card = 0.99\n\n  // Are the boxes colliding / overlapping?\n  const isColliding = doRectanglesCollide(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    px1,\n    py1,\n    pw1,\n    ph1\n  )\n\n  // Direct line between boxes\n  const [dix0, diy0, dix1, diy1] = getLineBetweenRoundedRectangles(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    padStart,\n    px1,\n    py1,\n    pw1,\n    ph1,\n    padEnd\n  )\n\n  // Length of the direct line between boxes\n  const distanceBetween = getDistance(dix0, diy0, dix1, diy1)\n\n  /* ------------- RETURN A STRAIGHT ARROW ------------ */\n\n  // Should we just draw a straight line?\n  if (!isColliding && straights && card % 0.5 === 0) {\n    const [mpdx, mpdy] = getPointBetween(dix0, diy0, dix1, diy1, 0.5)\n    return [dix0, diy0, mpdx, mpdy, dix1, diy1, angle, angle - PI, angle]\n  }\n\n  /* -------------- RETURN A CURVED ARROW ------------- */\n\n  // How much are the two boxes overlapping?\n  let overlapEffect = isColliding\n    ? modulate(distanceBetween, [0, distance], [0, 1], true)\n    : 0\n\n  // How far away are the two boxes?\n  const distEffect = 1 - distanceBetween / distance\n\n  // How much should the stretch impact the arc?\n  const stretchEffect = modulate(\n    distanceBetween,\n    [stretchMin, stretchMax],\n    [1, 0],\n    true\n  )\n\n  // What should the curved line's arc be?\n  let arc = bow + stretchEffect * stretch\n\n  // How much should the angle's intermediacy (45degree-ness) affect the angle?\n  let angleOffset = modulate(\n    card * card, // a better curve here?\n    [0, 1],\n    [PI * 0.125, 0],\n    true\n  )\n\n  const distOffset = isColliding\n    ? PI * 0.5 * card\n    : modulate(\n        distEffect, // a better curve here?\n        [0.75, 1],\n        [0, PI * 0.5],\n        true\n      ) * card\n\n  const combinedOffset =\n    distOffset + angleOffset * (isColliding ? 1 - overlapEffect : 1)\n\n  /* ----------------- STARTING POINT ----------------- */\n\n  // Angle of the first box\n  const finalAngle0 =\n    overlapEffect >= 0.5\n      ? angle + PI * rot\n      : angle + Math.max(MIN_ANGLE, combinedOffset) * rot\n\n  // Deltas of starting angle\n  const [dx0, dy0] = getDelta(finalAngle0)\n\n  // Get ray intersection with rounded rectangle\n  const [[tsx, tsy]] = getRayRoundedRectangleIntersection(\n    cx0,\n    cy0,\n    dx0,\n    dy0,\n    px0,\n    py0,\n    pw0,\n    ph0,\n    padStart\n  )\n\n  // Get midpoint of startingintersected segment\n  const startSeg = getRectangleSegmentIntersectedByRay(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    cx0,\n    cy0,\n    dx0,\n    dy0\n  )\n\n  if (!startSeg) throw Error\n\n  // Find start point (quarter way between segment midpoint and ray intersection)\n  const [ssx0, ssy0, ssx1, ssy1] = startSeg\n  const [smpx, smpy] = getPointBetween(ssx0, ssy0, ssx1, ssy1, 0.5)\n  ;[sx, sy] = getPointBetween(\n    tsx,\n    tsy,\n    smpx,\n    smpy,\n    isColliding ? Math.max(overlapEffect, 0.15) : 0.15\n  )\n\n  arc *= 1 + (Math.max(-2, Math.min(distEffect, 2)) * card - overlapEffect) / 2\n\n  if (isColliding) {\n    arc = arc < 0 ? Math.min(arc, -0.5) : Math.max(arc, 0.5)\n  }\n\n  /* ------------------ ENDING POINT ------------------ */\n\n  if (overlapEffect >= 0.5) {\n    // If overlapping, use the same angle as the start\n    const rayAngle = getAngle(cx0, cy0, smpx, smpy)\n    const [dx1, dy1] = getDelta(rayAngle)\n    ;[[ex, ey]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      dx1,\n      dy1,\n      px1,\n      py1,\n      pw1,\n      ph1,\n      padEnd\n    )\n  } else {\n    // Calculate an angle based on distance, overlap and intermediacy\n    const distOffset1 = modulate(distEffect, [0.75, 1], [0, 1], true)\n\n    const overlapEffect1 = isColliding\n      ? modulate(overlapEffect, [0, 1], [0, PI / 8], true)\n      : 0\n\n    const cardEffect1 = modulate(card * distOffset1, [0, 1], [0, PI / 16], true)\n\n    const combinedOffset =\n      distEffect * (PI / 12) +\n      (cardEffect1 + overlapEffect1) +\n      (distOffset + angleOffset) / 2\n\n    const finalAngle1 =\n      overlapEffect >= 0.5\n        ? angle + PI * rot\n        : angle + PI - Math.max(combinedOffset, MIN_ANGLE) * rot\n\n    // Deltas of ending angle\n    const [dx1, dy1] = getDelta(finalAngle1)\n\n    // Get ray intersection with ending rounded rectangle\n    const [[tex, tey]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      dx1,\n      dy1,\n      px1,\n      py1,\n      pw1,\n      ph1,\n      padEnd\n    )\n\n    // Get midpoint of ending intersected segment\n    const endSeg = getRectangleSegmentIntersectedByRay(\n      px1,\n      py1,\n      pw1,\n      ph1,\n      cx1,\n      cy1,\n      dx1,\n      dy1\n    )\n\n    if (!endSeg) throw Error\n\n    const [sex0, sey0, sex1, sey1] = endSeg\n    const [empx, empy] = getPointBetween(sex0, sey0, sex1, sey1, 0.5)\n\n      // Offset end point toward segment midpoint\n    ;[ex, ey] = getPointBetween(\n      tex,\n      tey,\n      empx,\n      empy,\n      0.25 + overlapEffect * 0.25\n    )\n  }\n\n  /* ------------------- DRAW ARROWS ------------------ */\n\n  // Get midpoints.\n  const [mx1, my1] = getPointBetween(sx, sy, ex, ey, 0.5)\n  const [tix, tiy] = getPointBetween(\n    sx,\n    sy,\n    ex,\n    ey,\n    Math.max(-1, Math.min(1, 0.5 + arc)) // Clamped to 2\n  )\n\n  // Rotate them (these are our two potential corners)\n  const [cixA, ciyA] = rotatePoint(tix, tiy, mx1, my1, (PI / 2) * rot)\n  const [cixB, ciyB] = rotatePoint(tix, tiy, mx1, my1, (PI / 2) * -rot)\n\n  // If we're colliding, pick the furthest corner from the end point.\n  let [cix, ciy] =\n    isColliding &&\n    getDistance(cixA, ciyA, cx1, cy1) < getDistance(cixB, ciyB, cx1, cy1)\n      ? [cixB, ciyB]\n      : [cixA, ciyA]\n\n  // Start and end angles\n  const as = getAngle(cix, ciy, sx, sy)\n  const ae = getAngle(cix, ciy, ex, ey)\n\n  return [sx, sy, cix, ciy, ex, ey, ae, as, getAngle(sx, sy, ex, ey)]\n}\n"]},"metadata":{},"sourceType":"module"}